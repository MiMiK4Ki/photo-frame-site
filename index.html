<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>スマホ写真フレーム合成（端末内処理・無送信）</title>
  <!-- 外部送信は同一オリジンのみ。ユーザー画像は送信されません -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src 'self' blob: data:; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'; connect-src 'self'; media-src 'none'; object-src 'none'; frame-ancestors 'none'">
  <style>
    :root { --bg:#0b1020; --fg:#e5e7eb; --muted:#94a3b8; --accent:#38bdf8; --line:#1e293b; }
    *{box-sizing:border-box}
    html,body{margin:0; padding:0; background:var(--bg); color:var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif;}
    header{position:sticky; top:0; backdrop-filter:saturate(140%) blur(8px); background:rgba(11,16,32,.7); padding:12px 16px; border-bottom:1px solid var(--line); display:flex; align-items:center; gap:10px; z-index:10}
    header h1{font-size:16px; margin:0;}
    main{max-width:520px; margin:0 auto; padding:16px;}
    .card{background:#0b1220; border:1px solid var(--line); border-radius:16px; padding:14px;}
    .section{display:flex; flex-direction:column; gap:12px}
    .drop{border:2px dashed #334155; border-radius:14px; padding:18px; text-align:center; cursor:pointer;}
    .drop.dragover{background:#0f1a2b; border-color: var(--accent);}    
    .hint{color:var(--muted); font-size:12px;}
    button, .btn{background:linear-gradient(180deg,#1e293b,#0f172a); border:1px solid #334155; color:var(--fg); padding:10px 14px; border-radius:12px; cursor:pointer;}
    button:disabled{opacity:.5; cursor:not-allowed}
    .actions{display:flex; gap:8px; flex-wrap:wrap;}
    .preview{background:#020617; border:1px solid #1f2937; border-radius:14px; padding:12px;}
    canvas{width:100%; height:auto; display:block; margin:0 auto; border-radius:12px}
    label{display:block; font-size:12px; color:var(--muted); margin-bottom:6px;}
    input[type="range"], input[type="number"]{width:100%;}
    .kbd{font-family: ui-monospace, monospace; border:1px solid #334155; border-radius:6px; padding:2px 6px; background:#0b1220;}
    details{border:1px solid var(--line); border-radius:12px; overflow:hidden}
    details>summary{list-style:none; padding:12px 14px; background:#0a1426; cursor:pointer; font-weight:600}
    details>summary::-webkit-details-marker{display:none}
    details[open]{border-color:#335b8d}
    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px}
    @media (max-width:420px){ .grid2{grid-template-columns:1fr} }
  </style>
</head>
<body>
  <main style="max-width:520px;margin:0 auto;padding:16px;display:flex;flex-direction:column;gap:12px">
    <!-- プレビュー（最上部） -->
    <div class="card preview">
      <canvas id="canvas" width="832" height="1600" aria-label="合成プレビュー"></canvas>
    </div>

    <!-- 画像選択（元写真） -->
    <div class="card">
      <div id="drop" class="drop" tabindex="0" role="button" aria-label="画像を選択/ドロップ">
        <p style="margin:6px 0 10px 0">ここに <span class="kbd">タップ/クリック</span> または ドラッグ&ドロップ</p>
        <p class="hint">対応: JPG/PNG/HEIC/HEIF（ブラウザ対応次第） / 出力横幅は常に <strong>832px固定</strong></p>
        <input id="file" type="file" accept="image/*" hidden />
      </div>
    </div>

    <!-- 差し込み用の正方形画像（任意） -->
    <div class="card">
      <label>差し込み用の正方形画像（任意）</label>
      <input id="square" type="file" accept="image/*" />
      <p class="hint">未選択時は元写真から自動生成（横幅フィット・上下トリミング）</p>
    </div>

    <!-- アクション（ダウンロード／リセットのみ） -->
    <div class="card actions" style="justify-content:space-between">
      <a id="btnDownload" class="btn" download="framed.png" href="#" aria-disabled="true">PNGをダウンロード</a>
      <button id="btnClear">リセット</button>
    </div>
  </main>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const drop = $("drop"), file = $("file"), canvas = $("canvas"), squareInput=$("square");
  const btnDownload=$("btnDownload"), btnClear=$("btnClear");

  const ctx = canvas.getContext('2d');

  /** 固定パラメータ */
  const OUT_W = 832; // 常に832px
  // 下部フレーム内の差し込み枠（出力座標系で指定）
  const SLOT = { left:33, top:119, right:138, bottom:221 };

  /** 現在の状態 */
  let state = {
    photo: null,         // ImageBitmap for user photo (EXIF補正)
    photoW: 0,
    photoH: 0,
    frameTop: null,      // ImageBitmap
    frameBottom: null,   // ImageBitmap
    square: null         // ImageBitmap（任意）
  };

  const preloadFrames = async () => {
    try { const r = await fetch('./frames/top.png'); if (r.ok) state.frameTop = await createImageBitmap(await r.blob()); } catch(_){ }
    try { const r = await fetch('./frames/bottom.png'); if (r.ok) state.frameBottom = await createImageBitmap(await r.blob()); } catch(_){ }
    render();
  };

  async function loadImageFromFile(file){
    try { return await createImageBitmap(file, { imageOrientation: 'from-image' }); }
    catch(err){
      return await new Promise((resolve, reject) => {
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => { const c=document.createElement('canvas'); c.width=img.naturalWidth; c.height=img.naturalHeight; c.getContext('2d').drawImage(img,0,0); createImageBitmap(c).then(resolve); URL.revokeObjectURL(url); };
        img.onerror = reject; img.src = url;
      });
    }
  }

  // 画像選択イベント
  drop.addEventListener('click', () => file.click());
  drop.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); file.click(); }});
  drop.addEventListener('dragover', (e)=>{ e.preventDefault(); drop.classList.add('dragover'); });
  drop.addEventListener('dragleave', ()=> drop.classList.remove('dragover'));
  drop.addEventListener('drop', async (e)=>{
    e.preventDefault(); drop.classList.remove('dragover');
    const f = e.dataTransfer.files && e.dataTransfer.files[0]; if(!f) return;
    await onPhotoSelected(f);
  });
  file.addEventListener('change', async ()=>{
    const f = file.files && file.files[0]; if(!f) return;
    await onPhotoSelected(f);
  });

  async function onPhotoSelected(f){
    if(!f.type.startsWith('image/')){ alert('画像ファイルを選択してください'); return; }
    state.photo = await loadImageFromFile(f);
    state.photoW = state.photo.width; state.photoH = state.photo.height;
    render(); // 常に即時合成
  }

  squareInput.addEventListener('change', async ()=>{
    const f = squareInput.files && squareInput.files[0]; if(!f) { state.square=null; render(); return; }
    state.square = await loadImageFromFile(f); render();
  });

  function computeHeights(){
    // 832px幅に合わせた元写真の実寸比から高さを自動算出
    const photoH = state.photo ? Math.round(OUT_W * (state.photoH / state.photoW)) : 1216;
    const topH = state.frameTop ? Math.round(state.frameTop.height * (OUT_W / state.frameTop.width)) : 0;
    const botH = state.frameBottom ? Math.round(state.frameBottom.height * (OUT_W / state.frameBottom.width)) : 0;
    return { photoH, topH, botH };
  }

  function render(){
    const { photoH, topH, botH } = computeHeights();
    const canvasW = OUT_W; const canvasH = topH + photoH + botH;
    canvas.width = canvasW; canvas.height = canvasH;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // 上フレーム
    if(state.frameTop){ ctx.drawImage(state.frameTop, 0, 0, canvasW, topH); }

    // 写真（cover: 横幅固定 832 / 高さは自動）
    if(state.photo){
      const areaW = OUT_W, areaH = photoH;
      const w = state.photoW, h = state.photoH;
      const s = Math.max(areaW / w, areaH / h); // cover基準
      const drawW = w * s; const drawH = h * s;
      const dx = (areaW - drawW)/2;
      const dy = topH + (areaH - drawH)/2;
      ctx.fillStyle = '#000'; ctx.fillRect(0, topH, areaW, areaH);
      ctx.drawImage(state.photo, dx, dy, drawW, drawH);
    }

    // 下フレーム
    if(state.frameBottom){ ctx.drawImage(state.frameBottom, 0, topH + photoH, OUT_W, botH); }

    // 差し込み画像
    const slotW = SLOT.right - SLOT.left; const slotH = SLOT.bottom - SLOT.top;
    const dx_slot = SLOT.left; const dy_slot = topH + photoH + SLOT.top;
    const srcImg = state.square || state.photo; // 正方形未選択なら元写真
    if(srcImg){
      const scaleToFit = slotW / srcImg.width; // 横幅合わせ
      const displayH = srcImg.height * scaleToFit;
      let sy = 0, sh = srcImg.height; // ソース切り出し
      if(displayH > slotH){
        const overflow = (displayH - slotH) / scaleToFit; // 画像座標系での余剰
        sy = overflow / 2; sh = srcImg.height - overflow; // 中央トリミング
      }
      ctx.drawImage(srcImg, 0, sy, srcImg.width, sh, dx_slot, dy_slot, slotW, slotH);
    }

    // 常にPNGでダウンロードリンク更新
    canvas.toBlob((blob)=>{
      if(!blob){ return; }
      const url = URL.createObjectURL(blob);
      btnDownload.href = url; btnDownload.download = 'framed.png';
      btnDownload.setAttribute('aria-disabled', 'false');
    }, 'image/png');
  }

  // リセット
  btnClear.addEventListener('click', ()=>{
    state = { photo:null, photoW:0, photoH:0, frameTop:state.frameTop, frameBottom:state.frameBottom, square:null };
    [file, squareInput].forEach(i=> i.value='');
    render();
  });

  // 初期化
  preloadFrames();
})();
</script>
</body>
</html>
